#### 现代加密技术
##### DES(Data Encryption Standard)

![](https://i.imgur.com/rX3CVlB.png)

	明文被分成64位的块，对每个块进行19次变换（替代和换位），其中16此变换由56位的密钥的不同排列形式控制（IBM使用的是128位的密钥），最后产生64位的密文块。

	输出结果：64位密文块

##### 三重DES(Triple-DES)
	利用两个相同密钥产生有效长度为112位的密钥进行三重DES加密操作。

	假设两个密钥分别是K1和K2，其算法的步骤如下：
	(1)用密钥K1进行DES加密
	(2)用K2对步骤(1)的结果进行DES加密
	(3)对步骤(2)的结果使用密钥K1进行DES加密
	需要花费DES三倍的时间

##### IDEA(International Data Encryption Algorithm)
	算法使用128位的密钥，把明文分成64位的块，进行8轮迭代加密。IDEA可以用硬件或软件实现，并且比DES快。

##### 高级加密标准(Advanced Encryption Standard, AES)
	AES最佳候选算法位Rijndael，AES支持128、192和256位三种密钥长度，能够在世界范围内免版税使用，提供安全级别足以保护未来20~30年内的数据，可以通过硬件或软件实现。

##### 流加密算法和RC4
	所谓流加密算法，就是将数据流与密钥生成二进制比特流进行异或运算的加密过程。这种算法采用以下两个步骤。
	(1)利用密钥K生成一个密钥流KS（伪随机序列）。
	(2)用密钥流KS与明文P进行“异或”运算，产生密文C。
			          C=P⊕KS(K)
	解密过程则是用密钥流与密文C进行“异或”运算，产生明文P。
			          P=C⊕KS(K)
	为了安全起见，对不同的明文必须使用不同的密钥流，否则容易被破解。
	密钥可选长度位64位或128位。
	速度极快，是DES的10倍。

##### 公钥加密算法
	公钥加密算法为非对称加密算法。P为明文，C为密文，E为公钥控制的加密算法，D为私钥控制的解密算法，这些参数满足下列三个条件。
	(1)D(E(P))=P。
	(2)不能由E导出D。
	(3)选择明文攻击（选择任意明文——密文对以确定未知的密钥）不能破解E。
	加密时计算C=E(P)，解密时计算P=D(C)

##### RSA(Rivest Shamir and Adleman)算法
	这是一种公钥加密算法，方法是按照下面的要求选择公钥和私钥。
	(1)选择两个大素数p和q（大于10^100）。
	(2)令n=p*q、z=(p-1)*(q-1)。
	(3)选择d与z互质。
	(4)选择e，使e*d=1(mod z)
	明文P被分成k位的块，k是满足2^k<n的最大整数，于是有0≤P<n。加密时计算
	                  C=P^e(mod n)
	这样公钥为（e，n）。解密时计算
	                  P=C^d(mod n)
	即私钥为（d，n）。

#### 报文摘要算法
	用于差错控制的报文检验时根据冗余位检查报文是否收到信道干扰的影响，与之类似的报文摘要方案是计算密码校验和，即固定长度的认证码，附加在消息后面发送，根据认证码检查报文是否被篡改。设M是可变长的报文，K是发送者和接收者共享的密钥，令MD＝Ck(M)，这就是算出的报文摘要（Message Digest）。

##### 散列（Hash）算法
	散列（Hash）算法将任意长度的二进制串映射为固定长度的二进制串，这个长度较小的二进制串称为散列值。散列值是一段数据唯一的、紧凑的表现形式。数据的散列值可以检验数据的完整性。
	通常的实现方案是对任意长的明文M进行单向散列变换，计算固定长度的位串作为报文摘要。对Hash函数h=H(M)的要求如下：
	(1)可用于任意大小的数据块
	(2)能产生固定大小的输出
	(3)软/硬件容易实现
	(4)对于任意m，找出x，满足H(x)=m，是不可计算的
	(5)对于任意x，找出y!=x，使得H(x)=H(y)，是不可计算的
	(6)找出(x,y)，使得H(x)=H(y)，是不可计算的
	前3项要求显而易见是实际应用和实现的需要。第4项要求就是所谓的单向性，这个条件使得攻击者不能由偷听的m得到原来的x。第5项要求是为了防止伪造攻击，使得攻击者不能用自己制造的假消息y冒充原来的消息x。第6项要求是为了对付生日攻击的。

##### MD5
	使用最广的报文摘要短发就是MD5，也是Hash函数中的一种。其基本思想就是用足够复杂的方法把报文位充分“弄乱”，使得每一位输出位都受到每一个输入位的影响。具体的操作分成下列几个步骤：
	(1)分组和填充。把明文报文按512位分组，最后要填充一定长度的"100……"，使得报文长度=448(mod 512)
	(2)附加。最后加上64位的报文长度字段，整个明文恰好为512的整数倍
	(3)初始化。置4个32位长的缓冲区ABCD跟别为：
	          A=01234567  B=89ABCDEF  C=FEDCBA98  D=76543210
	(4)处理。用4个不同的基本逻辑函数(E,G,H,I)进行4轮处理，每一轮以ABCD和当前512位的块作为署如，处理后送入ABCD（128位），产生128位的报文摘要。

![](https://i.imgur.com/uEXkxEx.png)

###### 安全散列算法
	安全散列算法(Secure Hash Algorithm, SHA)被定义为安全散列标准(Secure Hash Standard, SHS)。SHA-1是1994年修订的版本。这种算法接收的输入报文小于2^64位，产生160位的数据报文摘要。
	SHA算法比MD5慢，但是SHA的报文摘要长，有利于对抗野蛮攻击。

##### 散列式报文认证码(Hashed Message Authencation Code, HMAC)

	散列式报文认证码（Hashed Message Authentication Code，HMAC）是利用对称密钥生成报文认证码的散列算法，可以提供数据完整性数据源身份认证。
	为了说明HMAC的原理，假设H是一种散列函数（例如MD5或SHA-1）。
	H把任意长度的文本作为输入，产生长度为L位的输出（对于MD5，L=128；对于SHA-1，L=160）。
	并且假设K是由发送方和接收方共享的报文认证密钥，长度不大于64字节，如果小于64字节，后面加0，补够64字节。
	假定有下面两个64字节的串ipad（输入串）和open（输出串）
	ipad=0X36，重复64次；
	opad=0X5C，重复64此；
	函数HMAC把K和Text作为输入，产生
	HMACk(Text)=H(K⊕opad,H(K⊕ipad,Text))作为输出，即：
	(1)把K后附加0，生成64字节的串
	(2)将第(1)步产生的串与ipad按位异或
	(3)把Text附加在第(2)步产生的结果后面
	(4)对第(3)步产生的结果应用函数H
	(5)将第(1)步产生的串与opad按位异或
	(6)把第(4)步产生的结果附加在第(5)步结果的后面
	(7)对第(6)步产生的结果引用函数H，并输出计算结果
	HMAC的密钥长度至少为L位，更长的密钥并不能增强函数的安全性。
	HMAC允许把最后的输出截短到80位，这样更简单有效，且不损失安全强度。
	认证一个数据流（Text）的总费用接近于对该数据流进行散列的费用，对很长的数据流更是如此。
	HAMC使用现有的散列函数H而不用修改H的代码，这样可以使用已有的H代码库，而且可以随时用一个散列函数代替另一个散列函数。
	HMAC-MD5已经被IETF指定为Internet安全协议IPEsc的验证机制，提供数据源认证和数据完整性保护。
	HMAC的一个典型应用是在“提问/响应（Challenge/Response）”式身份认证中，认证流程如下。
	(1)先由客户端向服务器发出一个认证请求
	(2)服务器接到此请求后生成一个随机数并通过网络传输给客户端（此为提问）。
	(3)客户端将收到的随机数提供给ePass（数字证书的存储介质），由ePass使用该随机数与存储的密钥进行HMAC-MD5运算，并得到一个结果作为证据传给服务器（此为响应）。
	(4)与此同时，服务器也是用该随机数与存储在服务器数据库中的该客户密钥进行HMAC-MD5运算，如果服务器的运算结果与客户端传回的响应结果相同，则认为客户端是一个合法的用户。

#### 数字证书
	
##### 数字证书的概念
	
	数字证书是各类终端实体和最终用户在网上进行信息交流及商务活动的身份证明，在电子交易的各个环节，交易的各方都需验证对方数字证书的有效性，从而解决相互间信任问题。